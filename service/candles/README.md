# Описание проекта

## Candles

Здесь лежит код, который вам предстоит модифицировать для решения задачи хакатона.

> В `build.sbt` можете добавить в этот проект любые нужные зависимости


## Задача

Реализовать pipeline для обработки свечей котировок криптовалют

`object Main` - входная точка приложения. Функция `def start` будет вызвана когда приложение запустится – 
ее вам и нужно модифицировать. Структура требует, чтобы вы вернули не код-результат исполнения, а 
инстанс класса `akka.actor.ActorRef`, через который в ваш стрим будут попадать
объекты класса `rht.common.domain.candles.Candle`

---

**Итого**

Вам нужно сделать akka streams Graph, который будет принимать `Candle`
и как угодно обрабатывать его. 

### Про объект Candle

`interval` – интервал свечи 

`figi` – единый глобальный идентификатор ценной бумаги (здесь эмулируется, но является уникальным для каждой криптовалюты). 
Список доступных идентификаторов можно посмотреть в объекте `rht.common.domain.candles.Figis` 

`details` – детали свечи

`details.low` – нижняя граница стоимости инструмента в этой свечи

`details.high` – верхняя граница стоимости инструмента в этой свечи

`details.open` – стоимость инструмента на момент открытия этой свечи

`details.close` – стоимость инструмента на момент закрытия этой свечи

`details.openTime` – время открытия этой свечи


## Запуск приложения

1. Приложение можно запустить с помощью sbt. Добавлен плагин `sbt-revolver`, поэтому можно запускать с помощью команд `<module-name>/reStart`, 
а останавливать с помощью `<module-name>/reStop`
2. Работа с Kafka (**Очень важно**)

    Каждая команда должна отредактировать файл `application.conf` и заменить значение `group.id` на следующее: `hackathon-<team-name>`, где team-name – название вашей команды. Если указать другое имя, у вас не будет прав на чтение стрима. 
    Если все команды сделают одинаковое значение, только одна команда будет получать данные из стрима


## Заметки

#### ActorRef
Рекомендуется создать `Source` как `Source.actorRef` без backpressure, 
потому что это не будет поддерживаться источником сообщений. 
Можно установить размер буфера в 2000 сообщений – этого должно хватить для real-time обработки

Вы никак не ограничены в структуре графа, которым будет обрабатываться свеча
### Telegram Bot

#### Команды

Бот должен поддерживать следующие команды:
1. Подписка на стрим

    Бот принимает от пользователя `figi` валюты, за обновлением которой хочет следить. Бот каждые 3 секунды отправляет пользователю данные из соответствующей свечи 

2. Отписка от стрима 

    При получении сообщения бот прекращает отправку данных пользователю
    
    

*Опционально:*
Можно реализовать подписку на несколько `figi` одновременно и отписку от стрима конкретного `figi`

#### Реализация

Так как бэкенд для бота будет написан на Java, нужно решить, как организовать код. 
Это важно для передачи информации из стрима в бота.

Варианты:
1. Одно приложение (в одной программе запускается и стрим, и телеграм бот). 
Один будет процесс ОС, что означает, что данные будут находиться в общей памяти, а значит,
к ним легко получить доступ боту. Однако это же означает, что Java-разработчику придется
работать в этом sbt проекте, разбираться с его устройством, деталями работы и нужно будет следить за зависимостями 
в Java<->Scala коде

2. Разные приложения (разные процессы ОС). Это проще с точки зрения организации работы (каждый независимо делает свой модуль), но
требует дополнительной координации информации между процессами, так как общей памяти у них уже нет 


**Рекомендации**

- выбрать вариант 2, описанный выше (чтобы коллеге джависту было легче)
- использовать простое in-memory хранилище для обмена данными между приложениями (например, [redis](https://redis.io/), для которого есть куча библиотек на scala и java).
можно считать, что redis - `java ConcurrentHashMap`, в который есть доступ из любого процесса
- Telegram-боту делать polling данных из redis и отдавать заинтересованным пользователям

Если выберете вариант 1, можно делать то же самое с `ConcurrentHashMap`
